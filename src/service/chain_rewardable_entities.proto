// TODO: Design for different key formats - track "archetype" of key ... helium
// vs. solana, network prefixes etc.
// TODO: Consider OTHER Rewardable Entities (REs) in the future
// TODO: Signature STUFF in req's and reports

syntax = "proto3";

package helium.chain_rewardable_entities;

message solana_pub_key {
  // As string - base58 encode
  bytes value = 1;
}

message helium_pub_key {
  // As string - base58 check encode helium pubkey
  bytes value = 1;
}

// ------------------------------------------------------------------
// Helium Hotspot "rewardable entities" and their metadata
// ------------------------------------------------------------------
enum mobile_hotspot_device_type {
  mobile_hotspot_device_type_UNKNOWN =
      0; // Unknown device type, should not be used
  mobile_hotspot_device_type_CBRS = 1;
  mobile_hotspot_device_type_WIFI_INDOOR = 2;
  mobile_hotspot_device_type_WIFI_OUTDOOR = 3;
  mobile_hotspot_device_type_WIFI_DATA_ONLY = 4;
}

message mobile_hotspot_metadata {
  // Serial number of the mobile hotspot device (can be null or empty... in the
  // case of data-only devices)
  string serial_number = 2;
  // Type of the mobile hotspot device
  mobile_hotspot_device_type device_type = 3;
  // The asserted location in hex format
  string asserted_hex = 4;
  uint32 azimuth = 5;
}

// TODO: this meets mvp app needs, but could easily be extended
message iot_hotspot_metadata {
  // The asserted hex location of the IoT hotspot
  string asserted_hex = 2;
  uint32 elevation = 3;
  bool is_data_only = 4;
}

// ------------------------------------------------------------------
// Rewardable Entity <---> Controlling Wallet
// ------------------------------------------------------------------
enum entity_owner_type {
  // Unknown control type, should not be used
  entity_owner_type_UNKNOWN = 0;
  // Owner of the NFT
  entity_owner_type_DIRECT_OWNER = 1;
  // Controlling permission of the Welcome Pack
  entity_owner_type_WELCOME_PACK_OWNER = 2;
}

message entity_owner_info {
  // User wallet public key
  solana_pub_key wallet = 1;

  // Type of control relationship
  entity_owner_type type = 2;
}

message rewards_split_v1 {
  // They key of the on-chain struct that contains/performs the split
  solana_pub_key pub_key = 1;
  // The cron schedule of the split
  string schedule = 2;
  // The total shares of the split (user can specify any number of shares,
  // defaults to 100)
  uint32 total_shares = 3;
  // The recipients of the split
  repeated split_recipient_info_v1 recipients = 4;
}

message split_recipient_info_v1 {
  // The authority to control `recipient`. Useful for cases where a hot wallet
  // has rewards go to a cold wallet. You can safely ignore this field, unless
  // we implement a UI to make use of this smart contract feature.
  solana_pub_key authority = 1;
  // The wallet receiving this part of the split
  solana_pub_key recipient = 2;
  oneof reward_amount {
    // Fixed amount of tokens to be distributed to the wallet each period.
    uint64 fixed_amount = 3;
    // The shares for this wallet in the fanout. Divide into split.total_shares
    // for percentage.
    uint32 shares = 4;
  }
}

// ------------------------------------------------------------------
// updates
// ------------------------------------------------------------------
// Latest state of chain - effectively the data to be stored
// will be sent in a request to ingestor
// New messages should be created whenever
// - hotspot is deployed
// - hotspot metadata is updated
// - ownership structure changes
// - reward recipients are updated
// all edge cases need to be covered
message mobile_hotspot_update_v1 {
  // Block height when this data was sourced
  uint64 block_height = 1;
  uint64 block_time_seconds = 2;

  // Public key of the hotspot
  helium_pub_key pub_key = 3;

  // Solana public key of the hotspot's NFT (which we call an `asset`)
  solana_pub_key asset = 4;

  // Hotspot metadata
  mobile_hotspot_metadata metadata = 5;

  // Controlling ownership of the NFT
  entity_owner_info owner = 6;

  oneof rewards_destination {
    solana_pub_key rewards_recipient = 7;
    rewards_split_v1 rewards_split_v1 = 8;
  }
}

// Latest state of chain - effectively the data to be stored
// will be sent in a request to ingestor
// New messages should be created whenever
// - hotspot is deployed
// - hotspot metadata is updated
// - ownership structure changes
// - reward recipients are updated
message iot_hotspot_update_v1 {
  // Block height when this data was sourced
  uint64 block_height = 1;
  uint64 block_time_seconds = 2;

  // Public key of the hotspot
  helium_pub_key pub_key = 3;

  // Solana public key of the hotspot's NFT (which we call an `asset`)
  solana_pub_key asset = 4;

  // Hotspot metadata
  iot_hotspot_metadata metadata = 5;

  // Controlling ownership of the NFT
  entity_owner_info owner = 6;

  oneof rewards_destination {
    solana_pub_key rewards_recipient = 7;
    rewards_split_v1 rewards_split_v1 = 8;
  }
}

// Reports

// The update which ingestor/oracles will WRITE to s3
message mobile_hotspot_update_report_v1 {
  // The time the server received the request
  uint64 received_timestamp_ms = 1;
  // The request update
  mobile_hotspot_update_req_v1 report = 2;
}

// The update which ingestor/oracles will WRITE to s3
message iot_hotspot_update_report_v1 {
  // The time the server received the request
  uint64 received_timestamp_ms = 1;
  // The request update
  iot_hotspot_update_req_v1 update = 2;
}

// Service defs
message mobile_hotspot_update_req_v1 {
  mobile_hotspot_update_v1 update = 1;
  string signer = 2;
  bytes signature = 3;
}

message mobile_hotspot_update_resp_v1 { uint64 timestamp_ms = 1; }

message iot_hotspot_update_req_v1 {
  iot_hotspot_update_v1 update = 1;
  string signer = 2;
  bytes signature = 3;
}

message iot_hotspot_update_resp_v1 { uint64 timestamp_ms = 1; }

service chain_rewardable_entities {
  rpc submit_mobile_hotspot_change(mobile_hotspot_update_req_v1)
      returns (mobile_hotspot_update_resp_v1);
  rpc submit_iot_hotspot_change(iot_hotspot_update_req_v1)
      returns (iot_hotspot_update_resp_v1);
}
